#ifndef NEXUS_HPP
#define NEXUS_HPP

#include <Arduino.h>   // Include the Arduino library
#include <WiFi.h>      // Include the WiFi library
#include <esp_now.h>   // Include the ESP-NOW library

#include "Utilities/PacketBuffer.hpp" // Include the PacketBuffer utility
#include "Utilities/HyperList.hpp"    // Include the HyperList utility

// Define constants for Nexus
#define NEXUS_SCAN_INTERVAL 2000         // Interval for scanning devices
#define NEXUS_BUFFER_SIZE 32             // Buffer size for packets
#define NEXUS_HEADER_SIZE 12             // Header size for packets
#define NEXUS_MAX_PAYLOAD_SIZE (ESP_NOW_MAX_DATA_LEN - NEXUS_HEADER_SIZE) // Maximum payload size
const uint16_t NEXUS_COMMAND_SCAN = -1;    // Command for scanning devices

#define NEXUS_VERSION 0x01               // Version of Nexus

// NexusAddress structure definition
struct __attribute__((packed)) NexusAddress {
    uint8_t projectID;
    uint8_t groups;
    uint8_t deviceID;

    NexusAddress(uint8_t projectID = 0, uint8_t groups = 0, uint8_t deviceID = 0)
        : projectID(projectID), groups(groups), deviceID(deviceID) {}

    void toBuffer(uint8_t buffer[]) {
        buffer[0] = projectID;
        buffer[1] = groups;
        buffer[2] = deviceID;
    }

    String toString() const {
        return String(projectID) + "." + String(groups) + "." + String(deviceID);
    }

    bool operator==(const NexusAddress &other) const {
        return projectID == other.projectID && groups == other.groups && deviceID == other.deviceID;
    }

    bool operator!=(const NexusAddress &other) const {
        return !(*this == other);
    }
};

// NexusPacket structure definition
struct __attribute__((packed)) NexusPacket {
    uint8_t version;                // 1 byte
    NexusAddress source;            // 3 bytes
    NexusAddress destination;       // 3 bytes
    uint16_t sequenceNum;           // 2 bytes
    uint16_t command;               // 2 bytes
    uint8_t length;                 // 1 byte
    // Header size: 12 bytes
    uint8_t payload[NEXUS_MAX_PAYLOAD_SIZE]; // Payload

    NexusPacket(NexusAddress source = NexusAddress(), NexusAddress destination = NexusAddress(),
                uint16_t sequenceNum = 0, uint16_t command = 0, uint8_t length = 0, const uint8_t payload[] = nullptr)
        : version(NEXUS_VERSION), source(source), destination(destination),
          sequenceNum(sequenceNum), command(command), length(length) {
        if (payload != nullptr) {
            memcpy(this->payload, payload, length); // Copy the payload
        }
    }

    size_t size() const {
        return length + NEXUS_HEADER_SIZE; // Total packet size
    }

    String toString() const {
        String str = "NexusPacket {\n";
        str += "Version: " + String(version) + "\n";
        str += "Source: " + source.toString() + "\n";
        str += "Destination: " + destination.toString() + "\n";
        str += "SequenceNum: " + String(sequenceNum) + "\n";
        str += "Command: " + String(command) + "\n";
        str += "Length: " + String(length) + "\n";
        str += "Payload: ";
        for (size_t i = 0; i < length; i++) {
            str += String((char)payload[i]);
        }
        str += "\n}";
        return str;
    }
};

// Declare the onReceive function
void onReceive(const uint8_t *mac, const uint8_t *data, int len);

namespace Nexus {
    int CHANNEL = 0; // Communication channel
    const uint8_t BROADCAST_MAC_ADDRESS[] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};

    // Callback function pointers (initialized to nullptr)
    void (* onDeviceConnected)(const NexusAddress &who) = nullptr;
    void (* onDeviceDisconnected)(const NexusAddress &who) = nullptr;
    void (* onScanComplete)() = nullptr;
    bool (* onThisScanned)(const NexusAddress &who) = nullptr;
    void (* onPacketReceived)(const NexusPacket &packet) = nullptr;

    // Scan and connection variables
    uint32_t lastScan = 0;
    uint16_t scanSeq = 0;
    bool isScanComplete = false;
    bool shouldScan = true;

    NexusAddress THIS_ADDRESS(0, 0, 0);

    HyperList<NexusAddress> devices;      // List of devices
    HyperList<NexusAddress> scanResults;    // List of scan results

    PacketBuffer<NexusPacket> incomingBuffer(NEXUS_BUFFER_SIZE);
    HyperList<NexusPacket> outgoingPackets;

    // Set the address of this device.
    void setAddress(uint8_t projectID, uint8_t groups, uint8_t deviceID) {
        THIS_ADDRESS.projectID = projectID;
        THIS_ADDRESS.groups = groups;
        THIS_ADDRESS.deviceID = deviceID;
    }
    
    // Get the project ID.
    uint8_t getProjectID() {
        return THIS_ADDRESS.projectID;
    }
    
    // Calculate the group mask.
    uint8_t calcGroupMask(uint8_t groupID) {
        return 1 << groupID;
    }
    
    // Join a group.
    void joinGroup(uint8_t groupID) {
        THIS_ADDRESS.groups |= calcGroupMask(groupID);
    }
    
    // Leave a group.
    void leaveGroup(uint8_t groupID) {
        THIS_ADDRESS.groups &= ~calcGroupMask(groupID);
    }
    
    // Generate a random sequence number.
    uint16_t randomSequenceNum() {
        return random(0, 65535);
    }
    
    // Initialize the Nexus module.
    bool begin(const NexusAddress &address) {
        WiFi.mode(WIFI_STA);
        if (esp_now_init() != ESP_OK) return false;
        if (esp_now_register_recv_cb(onReceive) != ESP_OK) return false;

        esp_now_peer_info_t peerInfo = {};
        memcpy(peerInfo.peer_addr, BROADCAST_MAC_ADDRESS, 6);
        peerInfo.channel = CHANNEL;
        peerInfo.encrypt = false;
        if(esp_now_add_peer(&peerInfo) != ESP_OK) return false;

        THIS_ADDRESS = address;
        return true;
    }
    
    // Deinitialize the Nexus module.
    void end() {
        esp_now_deinit();
    }
    
    // Send a NexusPacket (removed extra destination parameter to match definition).
    bool sendPacket(const NexusPacket &packet) {
        if (packet.size() > ESP_NOW_MAX_DATA_LEN) return false;
        uint8_t data[packet.size()];
        memcpy(data, &packet, packet.size());
        esp_err_t result = esp_now_send(BROADCAST_MAC_ADDRESS, data, packet.size());
        return result == ESP_OK;
    }
    
    // Send data to a specific destination.
    bool sendData(uint16_t command, uint8_t length, uint8_t data[], const NexusAddress &destination) {
        NexusPacket packet(THIS_ADDRESS, destination, randomSequenceNum(), command, length, data);
        return sendPacket(packet);
    }
    
    // Send data to a specific device.
    bool sendToDevice(uint16_t command, uint8_t length, uint8_t data[], const uint8_t deviceID) {
        return sendData(command, length, data, NexusAddress(getProjectID(), 255, deviceID));
    }
    
    // Send data to a specific group.
    bool sendToGroup(uint16_t command, uint8_t length, uint8_t data[], const uint8_t groupID) {
        return sendData(command, length, data, NexusAddress(getProjectID(), calcGroupMask(groupID), 255));
    }
    
    // Read a NexusPacket.
    bool readPacket(NexusPacket &packet) {
        return incomingBuffer.dequeue(packet);
    }
    
    // Check if a packet is available.
    int available() {
        return incomingBuffer.size();
    }
    
    // Initiate a device scan.
    void scan() {
        shouldScan = true;
    }
    
    // Loop function for the Nexus module.
    void loop() {
        uint32_t now = millis();
        while (outgoingPackets.size() > 0) {
            auto packet = outgoingPackets[0];
            sendPacket(packet);
            outgoingPackets.remove(0);
        }

        if (now - lastScan >= NEXUS_SCAN_INTERVAL) {
            isScanComplete = true;
            // Process newly scanned devices
            for (size_t i = 0; i < scanResults.size(); i++) {
                auto device = scanResults[i];
                if (!devices.contains(device)) {
                    devices.addend(device);
                    if (onDeviceConnected != nullptr) {
                        onDeviceConnected(device);
                    }
                }
            }
            // Process disconnected devices
            for (size_t i = 0; i < devices.size(); i++) {
                auto device = devices[i];
                if (!scanResults.contains(device)) {
                    devices.remove(i);
                    if (onDeviceDisconnected != nullptr) {
                        onDeviceDisconnected(device);
                    }
                }
            }
            if (onScanComplete != nullptr) {
                onScanComplete();
            }
            if (shouldScan) {
                shouldScan = false;
                isScanComplete = false;
                lastScan = now;
                scanSeq = randomSequenceNum();
                scanResults.clear();
                sendPacket(NexusPacket(THIS_ADDRESS, NexusAddress(getProjectID(), 255, 255), scanSeq, NEXUS_COMMAND_SCAN, 0, nullptr));
            }
        }
    }
}

void onReceive(const uint8_t *mac, const uint8_t *data, int len) {
    NexusPacket packet;
    memcpy(&packet, data, len);
    if (packet.version != NEXUS_VERSION) return;
    
    if ((packet.destination.projectID == Nexus::THIS_ADDRESS.projectID) &&
        (packet.destination.groups & Nexus::THIS_ADDRESS.groups) &&
        (packet.destination.deviceID == Nexus::THIS_ADDRESS.deviceID || packet.destination.deviceID == 255)) {
        if (packet.command == NEXUS_COMMAND_SCAN) {
            if (packet.length == 1) {
                if (Nexus::scanSeq == --packet.sequenceNum) {
                    if (!Nexus::isScanComplete && !Nexus::scanResults.contains(packet.source)) {
                        Nexus::scanResults.addend(packet.source);
                    }
                }
            } else if (packet.length == 0) {
                if (Nexus::onThisScanned != nullptr) {
                    if (!Nexus::onThisScanned(packet.source)) {
                        return;
                    }
                }
                Nexus::outgoingPackets.addend(NexusPacket(Nexus::THIS_ADDRESS, packet.source, ++packet.sequenceNum, NEXUS_COMMAND_SCAN, 1, nullptr));
            }
        } else {
            if (Nexus::onPacketReceived != nullptr) {
                Nexus::onPacketReceived(packet);
            } else {
                Nexus::incomingBuffer.enqueue(packet);
            }
        }
    }
}

#endif // NEXUS_HPP
